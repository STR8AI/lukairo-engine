export default {
  async fetch(request) {
    return new Response(`
      <!DOCTYPE html>
      <html lang="en">
      <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
        <title>LUKAIRO Engine 3D Demo</title>
        <style>
          body, html {
            margin: 0;
            padding: 0;
            background: transparent;
            overflow: hidden;
          }
          #lukairo-engine {
            width: 100vw;
            height: 100vh;
            position: relative;
          }
        </style>
      </head>
      <body>
        <div id="lukairo-engine"></div>

        <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
        <script src="https://unpkg.com/three@0.158.0/examples/js/controls/OrbitControls.js"></script>
        <script>
        document.addEventListener("DOMContentLoaded", () => {
          const container = document.getElementById("lukairo-engine");

          const loaderText = document.createElement("div");
          loaderText.textContent = "Loading LUKAIRO Engine...";
          Object.assign(loaderText.style, {
            position: "absolute",
            top: "50%",
            left: "50%",
            transform: "translate(-50%, -50%)",
            color: "#00e5d1",
            fontFamily: "sans-serif",
            fontSize: "1.2rem",
            textShadow: "0 0 10px #00e5d1",
            zIndex: 10
          });
          container.appendChild(loaderText);

          const scene = new THREE.Scene();
          const camera = new THREE.PerspectiveCamera(65, container.offsetWidth / container.offsetHeight, 0.1, 1000);
          camera.position.z = 25;

          const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
          renderer.setSize(container.offsetWidth, container.offsetHeight);
          renderer.setPixelRatio(window.devicePixelRatio);
          renderer.setClearColor(0x000000, 0);
          container.appendChild(renderer.domElement);

          const controls = new THREE.OrbitControls(camera, renderer.domElement);
          controls.enableDamping = true;
          controls.dampingFactor = 0.05;
          controls.minDistance = 10;
          controls.maxDistance = 50;

          scene.add(new THREE.AmbientLight(0x00e5d1, 0.8));
          const light = new THREE.PointLight(0x00e5d1, 1.5, 100);
          light.position.set(0, 0, 20);
          scene.add(light);

          const core = new THREE.Mesh(
            new THREE.SphereGeometry(2, 64, 64),
            new THREE.MeshStandardMaterial({
              emissive: 0x00e5d1,
              emissiveIntensity: 1.2,
              color: 0x001010,
              metalness: 0.8,
              roughness: 0.2
            })
          );
          scene.add(core);

          const loader = new THREE.TextureLoader();
          const logos = [
            { img: "https://upload.wikimedia.org/wikipedia/commons/2/2f/Google_2015_logo.svg", orbit: 10 },
            { img: "https://upload.wikimedia.org/wikipedia/en/6/6b/Salesforce.com_logo.svg", orbit: 12 },
            { img: "https://upload.wikimedia.org/wikipedia/commons/0/08/Netflix_2015_logo.svg", orbit: 11 },
            { img: "https://upload.wikimedia.org/wikipedia/commons/4/44/Facebook_Logo.png", orbit: 14 }
          ];
          const nodes = [], beams = [], flows = [];
          let loaded = 0;

          logos.forEach((logo, i) => {
            loader.load(
              logo.img,
              (texture) => {
                const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: texture }));
                sprite.scale.set(2, 2, 2);
                sprite.userData.orbit = logo.orbit;
                scene.add(sprite);
                nodes.push(sprite);

                const beam = new THREE.Line(
                  new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]),
                  new THREE.LineBasicMaterial({ color: 0x00e5d1, transparent: true, opacity: 0.3 })
                );
                scene.add(beam); beams.push(beam);

                const flow = new THREE.Mesh(
                  new THREE.SphereGeometry(0.08, 8, 8),
                  new THREE.MeshBasicMaterial({ color: 0x00e5d1 })
                );
                scene.add(flow); flows.push(flow);

                loaded++;
                if (loaded === logos.length) {
                  loaderText.remove();
                  animate();
                }
              },
              undefined,
              () => console.warn("Failed to load:", logo.img)
            );
          });

          setTimeout(() => {
            if (loaded < logos.length) {
              loaderText.remove();
              animate();
            }
          }, 5000);

          const particleGeo = new THREE.BufferGeometry();
          const count = 2000;
          const pos = new Float32Array(count * 3);
          for (let i = 0; i < count * 3; i++) pos[i] = (Math.random() - 0.5) * 200;
          particleGeo.setAttribute("position", new THREE.BufferAttribute(pos, 3));
          const particleMat = new THREE.PointsMaterial({
            color: 0x00e5d1,
            size: 0.05,
            opacity: 0.3,
            transparent: true
          });
          const field = new THREE.Points(particleGeo, particleMat);
          scene.add(field);

          let pulseUp = true;
          function animate() {
            requestAnimationFrame(animate);
            const t = Date.now() * 0.001;

            const scale = core.scale.x + (pulseUp ? 0.002 : -0.002);
            core.scale.setScalar(scale);
            if (scale > 1.08) pulseUp = false;
            if (scale < 0.98) pulseUp = true;

            core.rotation.y += 0.003;
            field.rotation.y += 0.0005;
            controls.update();

            nodes.forEach((n, i) => {
              const a = t * 0.6 + i;
              const r = n.userData.orbit;
              n.position.x = Math.sin(a) * r;
              n.position.y = Math.cos(a) * r;
              n.lookAt(camera.position);

              beams[i].geometry.setFromPoints([new THREE.Vector3(), n.position.clone()]);
              const p = (Math.sin(t * 3 + i) + 1) / 2;
              flows[i].position.lerpVectors(new THREE.Vector3(), n.position, p);
            });

            renderer.render(scene, camera);
          }

          window.addEventListener("resize", () => {
            const width = container.offsetWidth;
            const height = container.offsetHeight;
            renderer.setSize(width, height);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
          });
        });
        </script>
      </body>
      </html>
    `, {
      headers: {
        'content-type': 'text/html;charset=UTF-8'
      }
    });
  }
}
