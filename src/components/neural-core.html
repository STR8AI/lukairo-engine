<!doctype html>
<html lang="en-CA">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="LUKAIRO Neural Core - 3D Visualization powered by Three.js">
  <title>LUKAIRO • Neural Core</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: system-ui, -apple-system, 'Segoe UI', sans-serif;
      background: #090c11;
      color: #E8EAED;
      overflow: hidden;
    }

    #neural-core-container {
      width: 100vw;
      height: 100vh;
      position: relative;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    .neural-core-fallback {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      padding: 2rem;
      background: rgba(17, 22, 28, 0.9);
      border-radius: 8px;
      max-width: 400px;
    }

    .neural-core-fallback.active {
      display: block;
    }

    .neural-core-fallback h2 {
      color: #6CEAD9;
      margin-bottom: 1rem;
      font-size: 1.5rem;
    }

    .neural-core-fallback p {
      color: #9AA0A6;
      line-height: 1.6;
      margin-bottom: 0.5rem;
    }

    .neural-core-info {
      position: absolute;
      bottom: 2rem;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      color: #9AA0A6;
      font-size: 0.875rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      pointer-events: none;
      opacity: 0.6;
    }

    @media (max-width: 640px) {
      .neural-core-info {
        font-size: 0.75rem;
        bottom: 1rem;
      }
    }

    /* Loading overlay */
    .neural-core-loading {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #090c11;
      z-index: 10;
      transition: opacity 0.5s ease-in-out;
    }

    .neural-core-loading.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .loading-spinner {
      width: 50px;
      height: 50px;
      border: 3px solid rgba(108, 234, 217, 0.3);
      border-top-color: #6CEAD9;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <div id="neural-core-container" role="main" aria-label="LUKAIRO Neural Core Visualization">
    <!-- Loading Overlay -->
    <div class="neural-core-loading" id="loading-overlay">
      <div class="loading-spinner"></div>
    </div>

    <!-- WebGL Fallback Message -->
    <div class="neural-core-fallback" id="fallback-message">
      <h2>WebGL Not Available</h2>
      <p>Your browser doesn't support WebGL or it's disabled.</p>
      <p>Please enable WebGL to view the Neural Core visualization.</p>
    </div>

    <!-- Info Display -->
    <div class="neural-core-info">
      LUKAIRO Neural Core • 3D Visualization
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script>
    // Neural Core Initialization
    (function() {
      'use strict';

      // Configuration
      const config = {
        texturePath: '/assets/textures/',
        textures: {
          gears: 'lukairo_gears.png',
          circuits: 'lukairo_circuits.png',
          globe: 'lukairo_globe.png'
        },
        layers: {
          gears: { radius: 1, speed: 0.003, reverse: false },
          circuits: { radius: 1.5, speed: 0.002, reverse: true },
          globe: { radius: 2, speed: 0.001, reverse: false }
        },
        starfield: {
          count: 1200,
          radius: 50
        }
      };

      let scene, camera, renderer, layers = {}, starfield;
      let animationId = null;
      let isPageVisible = true;

      // Check WebGL Support
      function checkWebGLSupport() {
        try {
          const canvas = document.createElement('canvas');
          const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
          return !!gl;
        } catch (e) {
          return false;
        }
      }

      // Initialize Scene
      function initScene() {
        const container = document.getElementById('neural-core-container');
        
        // Scene Setup
        scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x090c11, 10, 50);

        // Camera Setup
        camera = new THREE.PerspectiveCamera(
          45,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.z = 6;

        // Renderer Setup
        renderer = new THREE.WebGLRenderer({ 
          antialias: true, 
          alpha: true 
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setClearColor(0x090c11, 1);
        container.appendChild(renderer.domElement);

        // Handle WebGL Context Loss
        renderer.domElement.addEventListener('webglcontextlost', handleContextLost, false);
        renderer.domElement.addEventListener('webglcontextrestored', handleContextRestored, false);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        const pointLight1 = new THREE.PointLight(0x6CEAD9, 1, 100);
        pointLight1.position.set(5, 5, 5);
        scene.add(pointLight1);

        const pointLight2 = new THREE.PointLight(0x8AB4F8, 0.8, 100);
        pointLight2.position.set(-5, -5, 5);
        scene.add(pointLight2);

        // Create Starfield
        createStarfield();

        // Load Textures and Create Layers
        loadTextures();
      }

      // Create Starfield Background
      function createStarfield() {
        const geometry = new THREE.BufferGeometry();
        const vertices = [];
        
        for (let i = 0; i < config.starfield.count; i++) {
          const radius = config.starfield.radius;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos((Math.random() * 2) - 1);
          
          vertices.push(
            radius * Math.sin(phi) * Math.cos(theta),
            radius * Math.sin(phi) * Math.sin(theta),
            radius * Math.cos(phi)
          );
        }
        
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        
        const material = new THREE.PointsMaterial({
          color: 0x6CEAD9,
          size: 0.05,
          transparent: true,
          opacity: 0.6
        });
        
        starfield = new THREE.Points(geometry, material);
        scene.add(starfield);
      }

      // Load Textures
      function loadTextures() {
        const loader = new THREE.TextureLoader();
        const loadingManager = new THREE.LoadingManager();
        
        loadingManager.onLoad = () => {
          hideLoading();
        };

        loadingManager.onError = (url) => {
          console.warn('Texture loading failed:', url, '- using fallback');
        };

        // Load each layer texture
        Object.keys(config.layers).forEach(layerName => {
          const texturePath = config.texturePath + config.textures[layerName];
          
          loader.load(
            texturePath,
            (texture) => {
              createLayer(layerName, texture);
            },
            undefined,
            (error) => {
              console.warn(`Failed to load ${layerName} texture, creating without texture`);
              createLayer(layerName, null);
            }
          );
        });
      }

      // Create Individual Layer
      function createLayer(name, texture) {
        const layerConfig = config.layers[name];
        const geometry = new THREE.SphereGeometry(layerConfig.radius, 32, 32);
        
        const material = new THREE.MeshPhongMaterial({
          map: texture,
          transparent: true,
          opacity: 0.7,
          side: THREE.DoubleSide,
          wireframe: !texture
        });

        const mesh = new THREE.Mesh(geometry, material);
        mesh.userData = {
          speed: layerConfig.speed,
          reverse: layerConfig.reverse
        };
        
        layers[name] = mesh;
        scene.add(mesh);
      }

      // Hide Loading Overlay
      function hideLoading() {
        const overlay = document.getElementById('loading-overlay');
        if (overlay) {
          overlay.classList.add('hidden');
          setTimeout(() => {
            overlay.style.display = 'none';
          }, 500);
        }
      }

      // Show Fallback Message
      function showFallback() {
        const fallback = document.getElementById('fallback-message');
        if (fallback) {
          fallback.classList.add('active');
        }
        hideLoading();
      }

      // Handle Context Loss
      function handleContextLost(event) {
        event.preventDefault();
        if (animationId) {
          cancelAnimationFrame(animationId);
        }
        console.warn('WebGL context lost');
      }

      // Handle Context Restored
      function handleContextRestored() {
        console.log('WebGL context restored');
        initScene();
        animate();
      }

      // Animation Loop
      function animate() {
        animationId = requestAnimationFrame(animate);

        // Only animate if page is visible
        if (!isPageVisible) return;

        // Rotate layers
        Object.keys(layers).forEach(layerName => {
          const layer = layers[layerName];
          const direction = layer.userData.reverse ? -1 : 1;
          layer.rotation.y += layer.userData.speed * direction;
          layer.rotation.x += layer.userData.speed * 0.5 * direction;
        });

        // Slowly rotate starfield
        if (starfield) {
          starfield.rotation.y += 0.0001;
        }

        renderer.render(scene, camera);
      }

      // Handle Window Resize
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      // Handle Page Visibility
      function handleVisibilityChange() {
        isPageVisible = !document.hidden;
      }

      // Initialize
      function init() {
        if (!checkWebGLSupport()) {
          showFallback();
          return;
        }

        try {
          initScene();
          animate();
          
          // Event Listeners
          window.addEventListener('resize', onWindowResize, false);
          document.addEventListener('visibilitychange', handleVisibilityChange, false);
        } catch (error) {
          console.error('Failed to initialize Neural Core:', error);
          showFallback();
        }
      }

      // Start when DOM is ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
      } else {
        init();
      }

      // Cleanup on unload
      window.addEventListener('beforeunload', () => {
        if (animationId) {
          cancelAnimationFrame(animationId);
        }
        if (renderer) {
          renderer.dispose();
        }
      });
    })();
  </script>
</body>
</html>
