<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Lukairo Engine</title>

    <!-- Stylesheet â€” relative to this index.html -->
    <link rel="stylesheet" href="./lukairo-main.css">

    <link rel="stylesheet" href="./css/styles.css">

    <!-- Defer JS so it executes after parsing -->
    <script src="./engine.js" defer></script>
    <script src="./js/main.js"></script>
  </head>
  <body>
    <!-- Preserve existing page content; only asset paths and meta tags changed -->
    <h1>Welcome to Lukairo Engine</h1>
  </body>
</html>
        starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
        starGeo.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
        const starMat = new THREE.PointsMaterial({
          size: 1.2,
          sizeAttenuation: true,
          transparent: true,
          opacity: 0.75,
          vertexColors: true,
          blending: THREE.AdditiveBlending,
        });
        const stars = new THREE.Points(starGeo, starMat);
        scene.add(stars);
        const nebCanvas = document.createElement('canvas');
        nebCanvas.width = nebCanvas.height = 2048;
        const ngx = nebCanvas.getContext('2d');
        const grad1 = ngx.createRadialGradient(1024, 1024, 100, 1024, 1024, 1024);
        grad1.addColorStop(0, 'rgba(0,255,204,0.28)');
        grad1.addColorStop(0.3, 'rgba(0,180,255,0.18)');
        grad1.addColorStop(0.6, 'rgba(255,0,200,0.08)');
        grad1.addColorStop(1, 'rgba(0,0,0,0)');
        ngx.fillStyle = grad1;
        ngx.fillRect(0, 0, 2048, 2048);
        const nebTex = new THREE.CanvasTexture(nebCanvas);
        const nebula = new THREE.Mesh(
          new THREE.PlaneGeometry(1600, 1600),
          new THREE.MeshBasicMaterial({
            map: nebTex,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending,
          })
        );
        nebula.position.z = -500;
        scene.add(nebula);
        const loader = new THREE.TextureLoader();
        // Robust globe texture loading with fallback
        const globeMaterial = new THREE.MeshStandardMaterial({
          color: 0x0a3a34,
          metalness: 0.65,
          roughness: 0.3,
          emissive: 0x004a44,
          emissiveIntensity: 1.2,
        });
        const globe = new THREE.Mesh(new THREE.SphereGeometry(4.8, 128, 128), globeMaterial);
        scene.add(globe);
        loader.load(
          'https://storage.googleapis.com/msgsndr/B47X3dkLb4AkvxzX2Tck/media/68fdb1e49c7b3a610f587b93.png',
          (texture) => {
            globeMaterial.map = texture;
            globeMaterial.needsUpdate = true;
            console.log('Globe texture loaded successfully');
          },
          undefined,
          (error) => {
            console.warn('Globe texture failed to load, using fallback color', error);
          }
        );
        const halo1 = new THREE.Mesh(
          new THREE.SphereGeometry(5.3, 64, 64),
          new THREE.MeshBasicMaterial({
            color: 0x00ffee,
            wireframe: true,
            transparent: true,
            opacity: 0.12,
          })
        );
        scene.add(halo1);
        const halo2 = new THREE.Mesh(
          new THREE.SphereGeometry(5.8, 64, 64),
          new THREE.MeshBasicMaterial({
            color: 0x7de5ff,
            wireframe: true,
            transparent: true,
            opacity: 0.08,
          })
        );
        scene.add(halo2);
        const platformIcons = [
          'https://cdn-icons-png.flaticon.com/512/732/732221.png',
          'https://cdn-icons-png.flaticon.com/512/5968/5968534.png',
          'https://cdn-icons-png.flaticon.com/512/5968/5968899.png',
          'https://cdn-icons-png.flaticon.com/512/888/888879.png',
          'https://cdn-icons-png.flaticon.com/512/5968/5968342.png',
          'https://cdn-icons-png.flaticon.com/512/5968/5968759.png',
          'https://cdn-icons-png.flaticon.com/512/733/733553.png',
          'https://cdn-icons-png.flaticon.com/512/2111/2111615.png',
          'https://cdn-icons-png.flaticon.com/512/5968/5968906.png',
          'https://cdn-icons-png.flaticon.com/512/733/733585.png',
          'https://cdn-icons-png.flaticon.com/512/145/145807.png',
          'https://cdn-icons-png.flaticon.com/512/888/888853.png',
        ];
        const iconGeo = new THREE.PlaneGeometry(1.5, 1.5);
        const orbiters = [],
          beams = [],
          R = 13;
        platformIcons.forEach((url, i) => {
          const tex = loader.load(url);
          const mat = new THREE.MeshBasicMaterial({
            map: tex,
            transparent: true,
            side: THREE.DoubleSide,
            depthWrite: false,
          });
          const sprite = new THREE.Mesh(iconGeo, mat);
          sprite.userData = {
            angle: (i / platformIcons.length) * Math.PI * 2,
            speed: 0.0015 + Math.random() * 0.001,
            elev: Math.random() * 1 - 0.5,
            beatPhase: Math.random() * Math.PI * 2,
            pulseSpeed: 0.8 + Math.random() * 0.4,
          };
          scene.add(sprite);
          orbiters.push(sprite);
          const beamGeo = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(),
            new THREE.Vector3(),
          ]);
          const beam = new THREE.Line(
            beamGeo,
            new THREE.LineBasicMaterial({
              color: 0x00ffee,
              transparent: true,
              opacity: 0.4,
              linewidth: 2,
            })
          );
          scene.add(beam);
          beams.push(beam);
        });
        const particleCount = 120;
        const particleGeo = new THREE.BufferGeometry();
        const particlePositions = new Float32Array(particleCount * 3);
        const particleVelocities = [];
        for (let i = 0; i < particleCount; i++) {
          const angle = Math.random() * Math.PI * 2;
          const radius = 6 + Math.random() * 4;
          particlePositions[i * 3] = Math.cos(angle) * radius;
          particlePositions[i * 3 + 1] = (Math.random() - 0.5) * 3;
          particlePositions[i * 3 + 2] = Math.sin(angle) * radius;
          particleVelocities.push({
            angle,
            speed: 0.004 + Math.random() * 0.003,
            radius,
          });
        }
        particleGeo.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
        const particleMat = new THREE.PointsMaterial({
          color: 0x00ffee,
          size: 0.15,
          transparent: true,
          opacity: 0.7,
          blending: THREE.AdditiveBlending,
        });
        const particles = new THREE.Points(particleGeo, particleMat);
        scene.add(particles);
        let t0 = performance.now();
        function animate() {
          requestAnimationFrame(animate);
          const t = (performance.now() - t0) * 0.001;
          const beat = 0.5 + 0.5 * Math.sin(t * 1.8);
          stars.rotation.y += 0.0003;
          stars.rotation.x += 0.0001;
          nebula.rotation.z += 0.0001;
          globe.rotation.y += 0.002;
          globe.rotation.x += 0.0004;
          halo1.rotation.y -= 0.0008;
          halo1.rotation.x += 0.0003;
          halo2.rotation.y += 0.0006;
          halo2.rotation.x -= 0.0002;
          camera.position.x = Math.sin(t * 0.1) * 1.2;
          camera.position.y = 1 + Math.sin(t * 0.15) * 0.8;
          camera.lookAt(0, 0, 0);
          orbiters.forEach((o, i) => {
            o.userData.angle += o.userData.speed;
            const rr = R + Math.sin(t * 0.5 + i) * 0.5;
            o.position.set(
              Math.cos(o.userData.angle) * rr,
              Math.sin(o.userData.angle * 2.2) * 1.2 + o.userData.elev * 2.5,
              Math.sin(o.userData.angle) * rr
            );
            const scale = 1 + 0.15 * Math.sin(t * o.userData.pulseSpeed + o.userData.beatPhase);
            o.scale.setScalar(scale);
            o.lookAt(camera.position);
            const beam = beams[i];
            const arr = beam.geometry.attributes.position.array;
            arr[0] = o.position.x;
            arr[1] = o.position.y;
            arr[2] = o.position.z;
            const dir = o.position.clone().normalize().multiplyScalar(4.8);
            arr[3] = dir.x;
            arr[4] = dir.y;
            arr[5] = dir.z;
            beam.geometry.attributes.position.needsUpdate = true;
            beam.material.opacity = 0.2 + 0.25 * beat;
          });
          const particlePos = particles.geometry.attributes.position.array;
          particleVelocities.forEach((v, i) => {
            v.angle += v.speed;
            particlePos[i * 3] = Math.cos(v.angle) * v.radius;
            particlePos[i * 3 + 1] = Math.sin(v.angle * 3) * 0.8;
            particlePos[i * 3 + 2] = Math.sin(v.angle) * v.radius;
          });
          particles.geometry.attributes.position.needsUpdate = true;
          renderer.render(scene, camera);
        }
        animate();
        window.addEventListener(
          'resize',
          () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
          },
          { passive: true }
        );
        document.addEventListener(
          'mousemove',
          (e) => {
            const x = (e.clientX / window.innerWidth - 0.5) * 0.5;
            const y = (e.clientY / window.innerHeight - 0.5) * 0.5;
            camera.position.x += (x - camera.position.x) * 0.05;
            camera.position.y += (y - camera.position.y) * 0.05;
          },
          { passive: true }
        );
      });
    </script>
  </body>
</html>
